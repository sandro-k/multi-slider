<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-range-behavior/iron-range-behavior.html">
<link rel="import" href="../paper-behaviors/paper-inky-focus-behavior.html">

<!-- slider-knob is a modified version of [paper-slider, v2.0.2] -->

<!--
--single-slider-height: 2px
--slider-knob-color: var(--google-blue-700)
--slider-knob-disabled-knob-color: var(--paper-grey-400)
--slider-knob-font-color
--slider-knob-size: 30px
--slider-knob-start-border-color: var(--paper-grey-400)
--slider-knob-start-color: transparent
--slider-knob-start-color: var(--paper-grey-400)
--slider-knob-pin-color: var(--google-blue-700)

-->
<dom-module id="slider-knob">
  <template strip-whitespace>
    <style>
      :host {
        @apply --layout;
        @apply --layout-justified;
        @apply --layout-center;
        position: relative;
        width: 100%;
        cursor: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);

        --calculated-slider-knob-height: var(--single-slider-height, 2px);
        --calculated-slider-knob-size: var(--slider-knob-size, 30px);
      }

      /* focus shows the ripple */
      :host(:focus) {
        outline: none;
      }

      #sliderContainer {
        position: relative;
        width: 100%;

        height: calc(var(--calculated-slider-knob-size) + var(--calculated-slider-knob-height));
        margin-left: calc((var(--calculated-slider-knob-size) / 2) + var(--calculated-slider-knob-height) / 2);
        margin-right: calc((var(--calculated-slider-knob-size) / 2) + var(--calculated-slider-knob-height) / 2);
      }

      #sliderContainer:focus {
        outline: 0;
      }

      .bar-container {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }

      .ring > .bar-container {
        left: calc(5px + var(--calculated-slider-knob-height) / 2);
        transition: left 0.18s ease;
      }

      .ring.expand.dragging > .bar-container {
        transition: none;
      }

      .ring.expand:not(.pin) > .bar-container {
        left: calc(8px + var(--calculated-slider-knob-height) / 2);
      }

      .slider-knob {
        position: absolute;
        left: 0;
        top: 0;

        margin-left: calc((var(--calculated-slider-knob-size) / 2) * -1 - var(--calculated-slider-knob-height) / 2);
        width: calc(var(--calculated-slider-knob-size) + var(--calculated-slider-knob-height));
        height: calc(var(--calculated-slider-knob-size) + var(--calculated-slider-knob-height));
      }

      .transiting > .slider-knob {
        transition: left 0.08s ease;
      }

      .slider-knob:focus {
        outline: none;
      }

      .slider-knob.dragging {
        transition: none;
        cursor: col-resize;
      }

      .snaps > .slider-knob.dragging {
        transition: -webkit-transform 0.08s ease;
        transition: transform 0.08s ease;
      }

      .slider-knob-inner {
        margin: 10px;
        width: calc(100% - 20px);
        height: calc(100% - 20px);
        background-color: var(--slider-knob-color, var(--google-blue-700));
        border: 2px solid var(--slider-knob-color, var(--google-blue-700));
        border-radius: 50%;

        -moz-box-sizing: border-box;
        box-sizing: border-box;

        transition-property: -webkit-transform, background-color, border;
        transition-property: transform, background-color, border;
        transition-duration: 0.18s;
        transition-timing-function: ease;

        @apply --shadow-elevation-4dp;
      }

      .expand:not(.pin) > .slider-knob > .slider-knob-inner {
        -webkit-transform: scale(1.5);
        transform: scale(1.5);
      }

      .ring > .slider-knob > .slider-knob-inner {
        background-color: var(--slider-knob-start-color, transparent);
        border: 2px solid var(--slider-knob-start-border-color, var(--paper-grey-400));
      }

      .slider-knob-inner::before {
        background-color: var(--slider-knob-pin-color, var(--google-blue-700));
      }

      .pin > .slider-knob > .slider-knob-inner::before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -13px;
        width: 26px;
        height: 26px;
        border-radius: 50% 50% 50% 0;

        -webkit-transform: rotate(-45deg) scale(0) translate(0);
        transform: rotate(-45deg) scale(0) translate(0);
      }

      .slider-knob-inner::before,
      .slider-knob-inner::after {
        transition: -webkit-transform .18s ease, background-color .18s ease;
        transition: transform .18s ease, background-color .18s ease;
      }

      .pin.ring > .slider-knob > .slider-knob-inner::before {
        background-color: var(--slider-knob-pin-start-color, var(--paper-grey-400));
      }

      .pin.expand > .slider-knob > .slider-knob-inner::before {
        -webkit-transform: rotate(-45deg) scale(1) translate(17px, -17px);
        transform: rotate(-45deg) scale(1) translate(17px, -17px);
      }

      .pin > .slider-knob > .slider-knob-inner::after {
        content: attr(value);
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -16px;
        width: 32px;
        height: 26px;
        text-align: center;
        color: var(--slider-knob-font-color, #fff);
        font-size: 10px;

        -webkit-transform: scale(0) translate(0);
        transform: scale(0) translate(0);
        @apply --slider-knob-inner-text;
      }

      .pin.expand > .slider-knob > .slider-knob-inner::after {
        -webkit-transform: scale(1) translate(0, -17px);
        transform: scale(1) translate(0, -17px);
      }

      /* disabled state */
      #sliderContainer.disabled {
        pointer-events: none;
      }

      .disabled > .slider-knob > .slider-knob-inner {
        background-color: var(--slider-knob-disabled-knob-color, var(--paper-grey-400));
        border: 2px solid var(--slider-knob-disabled-knob-color, var(--paper-grey-400));
        -webkit-transform: scale3d(0.75, 0.75, 1);
        transform: scale3d(0.75, 0.75, 1);
      }

      .disabled.ring > .slider-knob > .slider-knob-inner {
        background-color: var(--slider-knob-start-color, transparent);
        border: 2px solid var(--slider-knob-start-border-color, var(--paper-grey-400));
      }

      paper-ripple {
        color: var(--slider-knob-color, var(--google-blue-700));
      }
    </style>

    <div id="sliderContainer"
         class$="[[_getClassNames(disabled, pin, snaps, immediateValue, min, expand, dragging, transiting)]]">
      <div
        class="bar-container"
        id="sliderBar">
      </div>

      <div id="sliderKnob"
           class="slider-knob"
           on-down="_knobdown"
           on-up="_resetKnob"
           on-track="_onTrack"
           on-transitionend="_knobTransitionEnd">
        <div class="slider-knob-inner" value$="[[displayFunction(immediateValue)]]">
          <slot name="knob" slot="knob"></slot>
        </div>
      </div>
    </div>

  </template>

  <script>
    class SliderKnob extends Polymer.mixinBehaviors([Polymer.IronA11yKeysBehavior, Polymer.IronFormElementBehavior, Polymer.IronRangeBehavior], Polymer.Element) {
      static get is () {
        return 'slider-knob'
      }

      static get properties () {
        return {
          /**
           * Used to customize the displayed value of the pin. E.g. the value can be prefixed with a '$' like '$99'
           */
          displayFunction: {
            type: Function,
            value () {
              return function (value) {
                return value
              }
            }
          },

          /**
           * If true, the slider thumb snaps to tick marks evenly spaced based
           * on the `step` property value.
           */
          snaps: {
            type: Boolean,
            value: false,
            notify: true
          },

          /**
           * If true, a pin with numeric value label is shown when the slider thumb
           * is pressed. Use for settings for which users need to know the exact
           * value of the setting.
           */
          pin: {
            type: Boolean,
            value: false,
            notify: true
          },

          /**
           * The number that represents the current secondary progress.
           */
          secondaryProgress: {
            type: Number,
            value: 0,
            notify: true,
            observer: '_secondaryProgressChanged'
          },

          /**
           * The immediate value of the slider.  This value is updated while the user
           * is dragging the slider.
           */
          immediateValue: {
            type: Number,
            value: 0,
            readOnly: true,
            notify: true
          },

          /**
           * If true, the knob is expanded
           */
          expand: {
            type: Boolean,
            value: false,
            readOnly: true
          },

          /**
           * True when the user is dragging the slider.
           */
          dragging: {
            type: Boolean,
            value: false,
            readOnly: true
          },

          transiting: {
            type: Boolean,
            value: false,
            readOnly: true
          },

        }
      }

      static get observers () {
        return [
          '_updateKnob(value, min, max, snaps, step)',
          '_valueChanged(value)',
          '_immediateValueChanged(immediateValue)'
        ]
      }

      get keyBindings () {
        return {
          'left': '_leftKey',
          'right': '_rightKey',
          'down pagedown home': '_decrementKey',
          'up pageup end': '_incrementKey'
        }
      }

      ready () {
        super.ready()
        this._ensureAttribute('tabindex', 0)
        this._ensureAttribute('role', 'slider')
      }

      /**
       * Increases value by `step` but not above `max`.
       * @method increment
       */
      increment () {
        this.value = this._clampValue(this.value + this.step)
      }

      /**
       * Decreases value by `step` but not below `min`.
       * @method decrement
       */
      decrement () {
        this.value = this._clampValue(this.value - this.step)
      }

      _updateKnob (value, min, max, snaps, step) {
        this.setAttribute('aria-valuemin', min)
        this.setAttribute('aria-valuemax', max)
        this.setAttribute('aria-valuenow', value)

        this._positionKnob(this._calcRatio(value) * 100)
      }

      _valueChanged () {
        this.fire('value-change', {composed: true})
      }

      _immediateValueChanged () {
        if (this.dragging) {
          this.fire('immediate-value-change', {composed: true})
        } else {
          this.value = this.immediateValue
        }
      }

      _secondaryProgressChanged () {
        this.secondaryProgress = this._clampValue(this.secondaryProgress)
      }

      _expandKnob () {
        this._setExpand(true)
      }

      _resetKnob () {
        this.cancelDebouncer('expandKnob')
        this._setExpand(false)
      }

      _positionKnob (ratio) {
        this._setImmediateValue(this._calcStep(this._calcKnobPosition(ratio)))
        this._setRatio(this._calcRatio(this.immediateValue) * 100)

        this.$.sliderKnob.style.left = `${this.ratio}%`
        if (this.dragging) {
          this._knobstartx = (this.ratio * this._w) / 100
          this.translate3d(0, 0, 0, this.$.sliderKnob)
        }
      }

      _calcKnobPosition (ratio) {
        return (this.max - this.min) * ratio / 100 + this.min
      }

      _onTrack (event) {
        event.stopPropagation()
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event)
            break
          case 'track':
            this._trackX(event)
            break
          case 'end':
            this._trackEnd()
            break
        }
      }

      _trackStart (event) {
        this._setTransiting(false)
        this._w = this.$.sliderBar.offsetWidth
        this._x = this.ratio * this._w / 100
        this._startx = this._x
        this._knobstartx = this._startx
        this._minx = -this._startx
        this._maxx = this._w - this._startx
        this.$.sliderKnob.classList.add('dragging')
        this._setDragging(true)
      }

      _trackX (event) {
        if (!this.dragging) {
          this._trackStart(event)
        }

        let direction = this._isRTL ? -1 : 1
        let dx = Math.min(
          this._maxx, Math.max(this._minx, event.detail.dx * direction))
        this._x = this._startx + dx

        let immediateValue = this._calcStep(this._calcKnobPosition(this._x / this._w * 100))
        this._setImmediateValue(immediateValue)

        // update knob's position
        let translateX = ((this._calcRatio(this.immediateValue) * this._w) - this._knobstartx)
        this.translate3d(translateX + 'px', 0, 0, this.$.sliderKnob)
      }

      _trackEnd () {
        let s = this.$.sliderKnob.style

        this.$.sliderKnob.classList.remove('dragging')
        this._setDragging(false)
        this._resetKnob()
        this.value = this.immediateValue

        s.transform = s.webkitTransform = ''

        this.fire('change', {composed: true})
      }

      _knobdown (event) {
        console.log('_knobdown', arguments)
        this._expandKnob()

        // cancel selection
        event.preventDefault()

        // set the focus manually because we will called prevent default
        this.focus()
      }

      _knobTransitionEnd (event) {
        if (event.target === this.$.sliderKnob) {
          this._setTransiting(false)
        }
      }

      _mergeClasses (classes) {
        return Object.keys(classes).filter(
          function (className) {
            return classes[className]
          }).join(' ')
      }

      _getClassNames () {
        return this._mergeClasses({
          disabled: this.disabled,
          pin: this.pin,
          snaps: this.snaps,
          ring: this.immediateValue <= this.min,
          expand: this.expand,
          dragging: this.dragging,
          transiting: this.transiting
        })
      }

      get _isRTL () {
        if (this.__isRTL === undefined) {
          this.__isRTL = window.getComputedStyle(this)['direction'] === 'rtl'
        }
        return this.__isRTL
      }

      _leftKey (event) {
        console.log('_leftKey', arguments)
        if (this._isRTL)
          this._incrementKey(event)
        else
          this._decrementKey(event)
      }

      _rightKey (event) {
        console.log('_rightKey', arguments)
        if (this._isRTL)
          this._decrementKey(event)
        else
          this._incrementKey(event)
      }

      _incrementKey (event) {
        if (!this.disabled) {
          if (event.detail.key === 'end') {
            this.value = this.max
          } else {
            this.increment()
          }
          this.fire('change')
          event.preventDefault()
        }
      }

      _decrementKey (event) {
        if (!this.disabled) {
          if (event.detail.key === 'home') {
            this.value = this.min
          } else {
            this.decrement()
          }
          this.fire('change')
          event.preventDefault()
        }
      }

      _changeValue (event) {
        this.value = event.target.value
        this.fire('change', {composed: true})
      }

      _inputKeyDown (event) {
        event.stopPropagation()
      }

      // create the element ripple inside the `sliderKnob`
      _createRipple () {
        this._rippleContainer = this.$.sliderKnob
        return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this)
      }

      // Hide the ripple when user is not interacting with keyboard.
      // This behavior is different from other ripple-y controls, but is
      // according to spec: https://www.google.com/design/spec/components/sliders.html
      _focusedChanged (receivedFocusFromKeyboard) {
        if (receivedFocusFromKeyboard) {
          this.ensureRipple()
        }
        if (this.hasRipple()) {
          // note, ripple must be un-hidden prior to setting `holdDown`
          if (receivedFocusFromKeyboard) {
            this._ripple.style.display = ''
          } else {
            this._ripple.style.display = 'none'
          }
          this._ripple.holdDown = receivedFocusFromKeyboard
        }
      }

      getEle (tag) { return this.shadowRoot.querySelector(tag) }

      /**
       * Fired when the slider-knob's value changes.
       *
       * @event value-change
       */

      /**
       * Fired when the slider-knob's immediateValue changes. Only occurs while the
       * user is dragging.
       *
       * To detect changes to immediateValue that happen for any input (i.e.
       * dragging, tapping, clicking, etc.) listen for immediate-value-changed
       * instead.
       *
       * @event immediate-value-change
       */

      /**
       * Fired when the slider-knob's value changes due to user interaction.
       *
       * Changes to the slider-knob's value due to changes in an underlying
       * bound variable will not trigger this event.
       *
       * @event change
       */
    }

    customElements.define(SliderKnob.is, SliderKnob)
  </script>
</dom-module>